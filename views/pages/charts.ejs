<div id="loader" class="loader-overlay hidden">
  <div class="spinner"></div>
</div>
<style>
/* Overlay sombre */
.loader-overlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(255, 255, 255, 0.7);
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 9999;
}

/* Cacher l'overlay */
.hidden {
  display: none !important;
}

/* Le spinner */
.spinner {
  width: 55px;
  height: 55px;
  border: 6px solid #ddd;
  border-top-color: #12A537; 
  border-radius: 50%;
  animation: spin 0.9s linear infinite;
}

/* Animation */
@keyframes spin {
  to {
    transform: rotate(360deg);
  }
}

.pie-container {
    width: 350px;
    height: 350px;
    margin: 0 auto;
}

.pie-container canvas {
    max-width: 100% !important;
    max-height: 100% !important;
}
</style>

<div class="row">
	<div class="col-12">
		<div class="page-title-box d-sm-flex align-items-center justify-content-between bg-galaxy-transparent">
			<h4 class="mb-sm-0">Tableau de bord du RGPH-5</h4>
			<div class="page-title-right">
				<ol class="breadcrumb m-0">
					<li class="breadcrumb-item active">Graphiques</li>
				</ol>
			</div>
		</div>
	</div>
	
	<div class="col-12">
		<div class="page-title-box d-sm-flex align-items-center justify-content-between bg-galaxy-transparent p-3 rounded shadow-sm">
			<div class="row g-3 w-100">
				<div class="row">
					<!-- R√©gion -->
  <div class="col-3">
    <label>R√©gion</label>
    <% if (user.canChangeRegion) { %>
      <!-- ROLE_GLOBAL : Select actif avec options pr√©charg√©es -->
      <select id="region" class="form-select">
        <option value="">-- S√©lectionner --</option>
        <% selects.regions.forEach(region => { %>
          <option value="<%= region.code_region %>"><%= region.region %></option>
        <% }); %>
      </select>
    <% } else { %>
      <!-- R√¥les REGIONAL, DEPARTEMENTAL, COMMUNAL : R√©gion fix√©e -->
      <% const defaultRegion = user.defaultRegion || selects.regions[0]?.code_region || ''; %>
      <% const defaultRegionName = selects.regions[0]?.region || 'R√©gion non disponible'; %>
      
      <input type="hidden" id="region" value="<%= defaultRegion %>">
      <div class="form-control-plaintext" style="padding:0.5rem; border:1px solid #ddd; background:#f8f9fa;">
        <%= defaultRegionName %>
      </div>
    <% } %>
  </div>
  
  <!-- D√©partement -->
<div class="col-3">
  <label>D√©partement</label>
  <% if (user.canChangeDepartement) { %>
    <select id="departement" class="form-select">
      <option value="">-- S√©lectionner --</option>
    </select>
  <% } else { %>
    <% const defaultDept = user.defaultDepartement || selects.departements[0]?.code_departement || ''; %>
    <% const defaultDeptName = selects.departements[0]?.departement || 'D√©partement non disponible'; %>
    
    <input type="hidden" id="departement" value="<%= defaultDept %>">
    <div class="form-control-plaintext" style="padding:0.5rem; border:1px solid #ddd; background:#f8f9fa;">
      <%= defaultDeptName %>
    </div>
  <% } %>
</div>
  
  <!-- Commune -->
  <div class="col-3">
    <label>Commune</label>
    <% if (user.canChangeCommune) { %>
      <!-- ROLE_GLOBAL, REGIONAL, DEPARTEMENTAL : Select actif -->
      <select id="commune" class="form-select">
        <option value="">-- S√©lectionner --</option>
      </select>
    <% } else { %>
      <!-- ROLE_COMMUNAL : Commune fix√©e -->
      <% const defaultCommune = user.defaultCommune || selects.communes[0]?.code_commune || ''; %>
      <% const defaultCommuneName = selects.communes[0]?.commune || 'Commune non disponible'; %>
      
      <input type="hidden" id="commune" value="<%= defaultCommune %>">
      <div class="form-control-plaintext" style="padding:0.5rem; border:1px solid #ddd; background:#f8f9fa;">
        <%= defaultCommuneName %>
      </div>
    <% } %>
  </div>
					
					<!-- ZD -->
					<div class="col-3">
						<label>Zone de d√©nombrement (ZD)</label>
						<select id="zd" class="form-select">
							<option value="">-- S√©lectionner --</option>
						</select>
					</div>
				</div>
			</div>
		</div>
	</div>
</div>

<div class="row">
	<div class="col-xl-6">
		<div class="card">
			<div class="card-header">
				<h4 class="card-title mb-0">PYRAMIDE DES √ÇGES</h4>
			</div>
			<div class="card-body">
				<canvas id="chartPyramide"></canvas>
			</div>
		</div>
	</div>
   
	<div class="col-xl-6">
		<div class="card">
			<div class="card-header">
				<h4 class="card-title mb-0">R√âPARTITION PAR SEXE</h4>
			</div>
			<div class="card-body">
				<canvas id="genderChart"></canvas>
			</div>
		</div>
	</div>
</div>

<div class="row">
	<div class="col-xl-6">
		<div class="card">
			<div class="card-header">
				<h4 class="card-title mb-0">PROGRESSION DE LA COLLECTE</h4>
			</div>
			<div class="card-body pie-container">
				<canvas id="popChartPie"></canvas>
			</div>
		</div>
	</div>
	
	<div class="col-xl-6">
		<div class="card">
			<div class="card-header">
				<h4 class="card-title mb-0">POPULATION PAR R√âGION</h4>
			</div>
			<div class="card-body pie-container">
				<canvas id="popChartBarRegions"></canvas>
			</div>
		</div>
	</div>
</div>

<script>
// Variables globales pour les graphiques
let genderChart = null;
let pyramideChart = null;
let popChartPie = null;
let popChartBarRegions = null;

// Cache intelligent avec expiration
const SmartCache = {
    store: {},
    expiration: {},
    TTL: 5 * 60 * 1000, // 5 minutes

    async fetch(url) {
        const cacheKey = url;
        const now = Date.now();
        
        // V√©rifier si le cache est valide
        if (this.store[cacheKey] && this.expiration[cacheKey] > now) {
            console.log('‚úÖ Cache hit:', url);
            return this.store[cacheKey];
        }
        
        console.log('üì• Fetching:', url);
        try {
            const res = await fetch(url);
            if (!res.ok) throw new Error(`HTTP ${res.status}: ${url}`);
            
            const data = await res.json();
            
            // Stocker dans le cache avec expiration
            this.store[cacheKey] = data;
            this.expiration[cacheKey] = now + this.TTL;
            
            return data;
        } catch (error) {
            console.error('‚ùå Fetch error:', error);
            throw error;
        }
    },
    
    clear() {
        this.store = {};
        this.expiration = {};
    }
};

// Fonctions utilitaires
function showLoader() {
    const loader = document.getElementById("loader");
    if (loader) loader.classList.remove("hidden");
}

function hideLoader() {
    const loader = document.getElementById("loader");
    if (loader) loader.classList.add("hidden");
}

function debounce(fn, delay = 300) {
    let timeout;
    return (...args) => {
        clearTimeout(timeout);
        timeout = setTimeout(() => fn(...args), delay);
    };
}

function resetSelect(select, placeholder = "-- S√©lectionner --") {
    if (!select || select.tagName !== 'SELECT') return;
    select.innerHTML = '';
    const option = new Option(placeholder, "");
    select.appendChild(option);
}

function populateSelect(select, items, valueField, textField) {
    if (!select || select.tagName !== 'SELECT') return;
    
    resetSelect(select);
    if (items && items.length > 0) {
        items.forEach(item => {
            const option = new Option(item[textField], item[valueField]);
            select.appendChild(option);
        });
        select.disabled = false;
    } else {
        select.disabled = true;
    }
}

// Fonction pour r√©cup√©rer la valeur d'un select (g√®re aussi les inputs hidden)
function getSelectValue(elementId) {
    const element = document.getElementById(elementId);
    if (!element) return '';
    
    if (element.tagName === 'INPUT' && element.type === 'hidden') {
        return element.value || '';
    }
    
    if (element.tagName === 'SELECT') {
        return element.value || '';
    }
    
    return '';
}

// Fonction principale pour mettre √† jour les graphiques
async function updateCharts(filters = {}) {
    // Nettoyer les filtres vides
    const cleanFilters = {};
    Object.entries(filters).forEach(([key, value]) => {
        if (value && value.toString().trim() !== '') {
            cleanFilters[key] = value;
        }
    });
    
    const queryString = new URLSearchParams(cleanFilters).toString();
    console.log('üìä Update charts with filters:', cleanFilters);
    
    showLoader();
    
    try {
        const stats = await SmartCache.fetch(`/stats?${queryString}&_cb=${Date.now()}`);
        
        // 1. GRAPHIQUE R√âPARTITION PAR SEXE
        updateGenderChart(stats.populationStats.hommes || 0, stats.populationStats.femmes || 0);
        
        // 2. PYRAMIDE DES √ÇGES
        updatePyramidChart(stats.pyramideAges || []);
        
        // 3. PROGRESSION DE LA COLLECTE
        updateProgressChart(stats.mainStats.collectee || 0, stats.mainStats.cartographie || 0);
        
        // 4. GRAPHIQUE PAR R√âGION (chargement sp√©cifique)
        await updateRegionsChart(cleanFilters);
        
    } catch (error) {
        console.error('‚ùå Error updating charts:', error);
    } finally {
        hideLoader();
    }
}

// Mise √† jour du graphique par sexe
function updateGenderChart(hommes, femmes) {
    const ctx = document.getElementById("genderChart");
    if (!ctx) return;
    
    const total = hommes + femmes;
    const data = [hommes, femmes];
    const labels = [
        `Hommes (${total > 0 ? ((hommes / total) * 100).toFixed(1) : 0}%)`,
        `Femmes (${total > 0 ? ((femmes / total) * 100).toFixed(1) : 0}%)`
    ];
    
    if (!genderChart) {
        genderChart = new Chart(ctx, {
            type: "doughnut",
            data: {
                labels: labels,
                datasets: [{
                    data: data,
                    backgroundColor: ["#12A537", "#F28F00"],
                    borderWidth: 2,
                    borderColor: "#fff"
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: true,
                plugins: {
                    legend: {
                        position: 'bottom',
                        labels: {
                            padding: 20,
                            usePointStyle: true
                        }
                    },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                const value = context.raw || 0;
                                const percentage = total > 0 ? ((value / total) * 100).toFixed(1) : 0;
                                return `${context.label}: ${value.toLocaleString()} (${percentage}%)`;
                            }
                        }
                    }
                }
            }
        });
    } else {
        genderChart.data.labels = labels;
        genderChart.data.datasets[0].data = data;
        genderChart.update();
    }
}

// Mise √† jour de la pyramide des √¢ges
function updatePyramidChart(pyramideData) {
    const ctx = document.getElementById("chartPyramide");
    if (!ctx) return;
    
    // Ordre des tranches d'√¢ge
    const ageOrder = ["0-4", "5-9", "10-14", "15-19", "20-24", "25-29", 
                     "30-34", "35-39", "40-44", "45-49", "50-54", "55-59", 
                     "60-64", "65-69", "70-74", "75-79", "80+"];
    
    // Trier les donn√©es selon l'ordre d√©fini
    const sortedData = [...pyramideData].sort((a, b) => 
        ageOrder.indexOf(a.age) - ageOrder.indexOf(b.age)
    );
    
    const labels = sortedData.map(p => p.age);
    const hommesData = sortedData.map(p => -(p.hommes || 0)); // N√©gatif pour l'effet pyramide
    const femmesData = sortedData.map(p => p.femmes || 0);
    
    if (!pyramideChart) {
        pyramideChart = new Chart(ctx, {
            type: "bar",
            data: {
                labels: labels,
                datasets: [
                    {
                        label: "Hommes",
                        data: hommesData,
                        backgroundColor: "rgba(18, 165, 55, 0.8)",
                        borderColor: "rgba(18, 165, 55, 1)",
                        borderWidth: 1
                    },
                    {
                        label: "Femmes",
                        data: femmesData,
                        backgroundColor: "rgba(242, 143, 0, 0.8)",
                        borderColor: "rgba(242, 143, 0, 1)",
                        borderWidth: 1
                    }
                ]
            },
            options: {
                indexAxis: "y",
                responsive: true,
                maintainAspectRatio: true,
                scales: {
                    x: {
                        stacked: true,
                        ticks: {
                            callback: function(value) {
                                return Math.abs(value).toLocaleString();
                            }
                        },
                        title: {
                            display: true,
                            text: "Population"
                        }
                    },
                    y: {
                        stacked: true,
                        title: {
                            display: true,
                            text: "Tranche d'√¢ge"
                        }
                    }
                },
                plugins: {
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                const label = context.dataset.label || "";
                                const value = Math.abs(context.raw || 0);
                                return `${label}: ${value.toLocaleString()}`;
                            }
                        }
                    }
                }
            }
        });
    } else {
        pyramideChart.data.labels = labels;
        pyramideChart.data.datasets[0].data = hommesData;
        pyramideChart.data.datasets[1].data = femmesData;
        pyramideChart.update();
    }
}

// Mise √† jour du graphique de progression
function updateProgressChart(collectee, carto) {
    const ctx = document.getElementById("popChartPie");
    if (!ctx) return;
    
    const restant = Math.max(0, carto - collectee);
    const pourcentage = carto > 0 ? ((collectee / carto) * 100).toFixed(1) : 0;
    
    const data = [collectee, restant];
    const labels = [
        `Collect√©e (${pourcentage}%)`,
        `√Ä collecter (${(100 - pourcentage).toFixed(1)}%)`
    ];
    
    if (!popChartPie) {
        popChartPie = new Chart(ctx, {
            type: "pie",
            data: {
                labels: labels,
                datasets: [{
                    data: data,
                    backgroundColor: ["#12A537", "#e0e0e0"],
                    borderWidth: 2,
                    borderColor: "#fff"
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: true,
                plugins: {
                    legend: {
                        position: 'bottom',
                        labels: {
                            padding: 20
                        }
                    },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                const value = context.raw || 0;
                                const total = carto;
                                const percentage = total > 0 ? ((value / total) * 100).toFixed(1) : 0;
                                return `${context.label}: ${value.toLocaleString()} (${percentage}%)`;
                            }
                        }
                    }
                }
            }
        });
    } else {
        popChartPie.data.labels = labels;
        popChartPie.data.datasets[0].data = data;
        popChartPie.update();
    }
}

// Mise √† jour du graphique par r√©gion

async function updateRegionsChart(filters) {
    const ctx = document.getElementById("popChartBarRegions");
    if (!ctx) return;
    
    try {
        // Nettoyer les filtres pour enlever les valeurs null/undefined
        const cleanFilters = {};
        for (const [key, value] of Object.entries(filters)) {
            if (value && value !== 'all' && value !== 'null' && value !== 'undefined') {
                cleanFilters[key] = value;
            }
        }
        
        // Construire l'URL correctement
        const queryString = new URLSearchParams(cleanFilters).toString();
        const url = `/charts${queryString ? `?${queryString}` : ''}`;
        
        console.log('üìä Fetching regions data from:', url);
        
        // R√©cup√©rer les donn√©es depuis la page charts
        const response = await fetch(url);
        
        if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        
        const html = await response.text();
        
        // Utiliser DOMParser pour extraire les donn√©es
        const parser = new DOMParser();
        const doc = parser.parseFromString(html, 'text/html');
        
        // Extraire les donn√©es depuis les √©l√©ments HTML ou scripts
        const regionsData = extractRegionsDataFromHTML(doc);
        
        if (!regionsData || regionsData.length === 0) {
            console.warn('‚ö†Ô∏è No regions data found');
            
            // Afficher un message si pas de donn√©es
            if (window.popChartBarRegions) {
                window.popChartBarRegions.destroy();
                window.popChartBarRegions = null;
            }
            
            // Optionnel: Afficher un message dans le canvas
            ctx.style.display = 'flex';
            ctx.style.alignItems = 'center';
            ctx.style.justifyContent = 'center';
            ctx.style.color = '#666';
            ctx.style.fontStyle = 'italic';
            ctx.innerHTML = '<div>Aucune donn√©e disponible pour cette s√©lection</div>';
            return;
        }
        
        // Pr√©parer les donn√©es pour le graphique
        const labels = regionsData.map(r => r.region || r.code_region || 'Inconnu');
        const collecteeData = regionsData.map(r => r.collectee || r.populationCollectee || 0);
        const cartoData = regionsData.map(r => r.carto || r.populationCarto || 0);
        
        // Si vous n'avez qu'une seule r√©gion, adapter les donn√©es
        if (regionsData.length === 1) {
            // Pour une seule r√©gion, on peut afficher les donn√©es d√©taill√©es
            const region = regionsData[0];
            console.log('üìà Single region data:', region);
        }
        
        console.log('üìä Chart data:', { labels, collecteeData, cartoData });
        
        // Cr√©er ou mettre √† jour le graphique
        if (!window.popChartBarRegions) {
            window.popChartBarRegions = new Chart(ctx, {
                type: "bar",
                data: {
                    labels: labels,
                    datasets: [
                        {
                            label: "Population Collect√©e",
                            data: collecteeData,
                            backgroundColor: "rgba(18, 165, 55, 0.7)",
                            borderColor: "rgba(18, 165, 55, 1)",
                            borderWidth: 1,
                            yAxisID: 'y'
                        },
                        {
                            label: "Population Cartographi√©e",
                            data: cartoData,
                            backgroundColor: "rgba(242, 143, 0, 0.7)",
                            borderColor: "rgba(242, 143, 0, 1)",
                            borderWidth: 1,
                            yAxisID: 'y'
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    plugins: {
                        legend: {
                            position: 'top',
                        },
                        tooltip: {
                            mode: 'index',
                            intersect: false,
                            callbacks: {
                                label: function(context) {
                                    const label = context.dataset.label || '';
                                    const value = context.raw || 0;
                                    const percentage = context.dataset.label === "Population Collect√©e" && 
                                                      cartoData[context.dataIndex] > 0 ? 
                                                      ` (${((value / cartoData[context.dataIndex]) * 100).toFixed(1)}%)` : '';
                                    return `${label}: ${value.toLocaleString()}${percentage}`;
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: "R√©gions",
                                font: {
                                    weight: 'bold'
                                }
                            },
                            ticks: {
                                maxRotation: 45,
                                minRotation: 45
                            }
                        },
                        y: {
                            type: 'linear',
                            display: true,
                            position: 'left',
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: "Population",
                                font: {
                                    weight: 'bold'
                                }
                            },
                            ticks: {
                                callback: function(value) {
                                    return value.toLocaleString();
                                }
                            }
                        }
                    }
                }
            });
        } else {
            // Mettre √† jour le graphique existant
            window.popChartBarRegions.data.labels = labels;
            window.popChartBarRegions.data.datasets[0].data = collecteeData;
            window.popChartBarRegions.data.datasets[1].data = cartoData;
            window.popChartBarRegions.update();
        }
        
        // Restaurer le style du canvas
        ctx.style.display = 'block';
        ctx.style.color = '';
        ctx.style.fontStyle = '';
        ctx.innerHTML = '';
        
    } catch (error) {
        console.error('‚ùå Error loading regions data:', error);
        
        // Afficher une erreur dans le canvas
        const ctx = document.getElementById("popChartBarRegions");
        if (ctx) {
            ctx.style.display = 'flex';
            ctx.style.alignItems = 'center';
            ctx.style.justifyContent = 'center';
            ctx.style.color = '#dc3545';
            ctx.style.fontWeight = 'bold';
            ctx.innerHTML = '<div>Erreur de chargement des donn√©es</div>';
        }
        
        // D√©truire le graphique en cas d'erreur
        if (window.popChartBarRegions) {
            window.popChartBarRegions.destroy();
            window.popChartBarRegions = null;
        }
    }
}

// Fonction pour extraire les donn√©es r√©gionales depuis le HTML
function extractRegionsDataFromHTML(doc) {
    try {
        // M√©thode 1: Chercher dans les scripts avec les donn√©es
        const dataScripts = doc.querySelectorAll('script[type="application/json"]');
        
        for (const script of dataScripts) {
            if (script.id === 'regions-data' || script.getAttribute('data-type') === 'regions') {
                return JSON.parse(script.textContent);
            }
        }
        
        // M√©thode 2: Chercher dans les √©l√©ments avec data-attributes
        const regionElements = doc.querySelectorAll('[data-region]');
        if (regionElements.length > 0) {
            return Array.from(regionElements).map(el => ({
                region: el.getAttribute('data-region'),
                code_region: el.getAttribute('data-code-region'),
                carto: parseInt(el.getAttribute('data-carto') || 0),
                collectee: parseInt(el.getAttribute('data-collectee') || 0)
            }));
        }
        
        // M√©thode 3: Chercher dans les tables ou listes
        const tables = doc.querySelectorAll('table');
        for (const table of tables) {
            if (table.classList.contains('regions-data') || table.id.includes('region')) {
                const rows = table.querySelectorAll('tbody tr');
                const data = [];
                
                rows.forEach(row => {
                    const cells = row.querySelectorAll('td');
                    if (cells.length >= 3) {
                        data.push({
                            region: cells[0].textContent.trim(),
                            code_region: cells[0].textContent.trim(),
                            carto: parseInt(cells[1].textContent.replace(/\D/g, '') || 0),
                            collectee: parseInt(cells[2].textContent.replace(/\D/g, '') || 0)
                        });
                    }
                });
                
                if (data.length > 0) return data;
            }
        }
        
        // M√©thode 4: Si vous avez des donn√©es globales (une seule r√©gion)
        const populationCarto = doc.querySelector('[data-id="population-carto"]');
        const populationCollectee = doc.querySelector('[data-id="population-collectee"]');
        
        if (populationCarto && populationCollectee) {
            return [{
                region: filters.region || 'R√©gion s√©lectionn√©e',
                code_region: filters.region || '',
                carto: parseInt(populationCarto.textContent.replace(/\D/g, '') || 0),
                collectee: parseInt(populationCollectee.textContent.replace(/\D/g, '') || 0)
            }];
        }
        
        return [];
        
    } catch (error) {
        console.error('‚ùå Error extracting regions data:', error);
        return [];
    }
}

// Fonction d'initialisation pour appeler updateRegionsChart
function initRegionsChart() {
    // R√©cup√©rer les filtres initiaux
    const filters = {
        region: document.getElementById('region')?.value || null,
        departement: document.getElementById('departement')?.value || null,
        commune: document.getElementById('commune')?.value || null,
        zd: document.getElementById('zd')?.value || null
    };
    
    updateRegionsChart(filters);
}

// Attacher les √©v√©nements quand le DOM est charg√©
document.addEventListener('DOMContentLoaded', function() {
    // Initialiser le graphique
    initRegionsChart();
    
    // √âcouter les changements de filtres
    const filterSelects = ['region', 'departement', 'commune', 'zd'];
    
    filterSelects.forEach(selectId => {
        const select = document.getElementById(selectId);
        if (select) {
            select.addEventListener('change', function() {
                const filters = {
                    region: document.getElementById('region')?.value || null,
                    departement: document.getElementById('departement')?.value || null,
                    commune: document.getElementById('commune')?.value || null,
                    zd: document.getElementById('zd')?.value || null
                };
                
                // D√©lai pour √©viter trop de requ√™tes
                clearTimeout(window.regionsChartTimeout);
                window.regionsChartTimeout = setTimeout(() => {
                    updateRegionsChart(filters);
                }, 300);
            });
        }
    });
});
// Initialisation de l'application
document.addEventListener("DOMContentLoaded", async () => {
    console.log('üöÄ Initializing charts dashboard...');
    
    const regionSelect = document.getElementById('region');
    const deptSelect = document.getElementById('departement');
    const comSelect = document.getElementById('commune');
    const zdSelect = document.getElementById('zd');
    
    const userRole = '<%= user.role %>';
    console.log('üë§ User role:', userRole);
    
    // Cache pour les donn√©es de localisation
    const locationCache = {
        departements: {},
        communes: {},
        zds: {}
    };
    
    // Fonction pour charger les options avec cache
    async function loadLocationOptions(url, select, valueField, textField, cacheKey = null) {
        if (!select || select.tagName !== 'SELECT') return [];
        
        // V√©rifier le cache
        if (cacheKey && locationCache[cacheKey]) {
            populateSelect(select, locationCache[cacheKey], valueField, textField);
            return locationCache[cacheKey];
        }
        
        resetSelect(select, "Chargement...");
        select.disabled = true;
        
        try {
            const data = await SmartCache.fetch(url);
            
            // Mettre en cache si n√©cessaire
            if (cacheKey) {
                locationCache[cacheKey] = data;
            }
            
            populateSelect(select, data, valueField, textField);
            return data;
        } catch (error) {
            console.error('‚ùå Error loading options:', error);
            resetSelect(select, "Erreur de chargement");
            select.disabled = true;
            return [];
        }
    }
    
    // Initialisation selon le r√¥le
    if (userRole === 'ROLE_GLOBAL' && regionSelect && regionSelect.tagName === 'SELECT') {
        // Charger toutes les r√©gions
        await loadLocationOptions('/api/location/regions', regionSelect, 'code_region', 'region');
    }
    
    // Pr√©charger les donn√©es selon la r√©gion actuelle
    const currentRegion = getSelectValue('region');
    if (currentRegion && deptSelect && deptSelect.tagName === 'SELECT') {
        await loadLocationOptions(
            `/api/location/departements?region=${currentRegion}`,
            deptSelect,
            'code_departement',
            'departement',
            `dept_${currentRegion}`
        );
    }
    
    // Gestion des √©v√©nements
    const debouncedUpdateCharts = debounce(updateCharts, 300);
    
    // √âv√©nement pour la r√©gion (si c'est un select actif)
    if (regionSelect && regionSelect.tagName === 'SELECT') {
        regionSelect.addEventListener("change", async () => {
            console.log('üîò Region changed:', regionSelect.value);
            
            // R√©initialiser les niveaux inf√©rieurs
            if (deptSelect && deptSelect.tagName === 'SELECT') {
                resetSelect(deptSelect);
                resetSelect(comSelect);
                resetSelect(zdSelect);
            }
            
            // Charger les d√©partements si une r√©gion est s√©lectionn√©e
            if (regionSelect.value) {
                await loadLocationOptions(
                    `/api/location/departements?region=${regionSelect.value}`,
                    deptSelect,
                    'code_departement',
                    'departement',
                    `dept_${regionSelect.value}`
                );
            }
            
            // Mettre √† jour les graphiques
            debouncedUpdateCharts({
                region: regionSelect.value,
                departement: '',
                commune: '',
                zd: ''
            });
        });
    }
    
    // √âv√©nement pour le d√©partement
    if (deptSelect && deptSelect.tagName === 'SELECT') {
        deptSelect.addEventListener("change", async () => {
            console.log('üîò Department changed:', deptSelect.value);
            
            // R√©initialiser les niveaux inf√©rieurs
            if (comSelect && comSelect.tagName === 'SELECT') {
                resetSelect(comSelect);
                resetSelect(zdSelect);
            }
            
            // Charger les communes si un d√©partement est s√©lectionn√©
            if (deptSelect.value) {
                await loadLocationOptions(
                    `/api/location/communes?departement=${deptSelect.value}`,
                    comSelect,
                    'code_commune',
                    'commune',
                    `com_${deptSelect.value}`
                );
            }
            
            // Mettre √† jour les graphiques
            debouncedUpdateCharts({
                region: getSelectValue('region'),
                departement: deptSelect.value,
                commune: '',
                zd: ''
            });
        });
    }
    
    // √âv√©nement pour la commune
    if (comSelect && comSelect.tagName === 'SELECT') {
        comSelect.addEventListener("change", async () => {
            console.log('üîò Commune changed:', comSelect.value);
            
            // R√©initialiser les ZDs
            if (zdSelect && zdSelect.tagName === 'SELECT') {
                resetSelect(zdSelect);
            }
            
            // Charger les ZDs si une commune est s√©lectionn√©e
            if (comSelect.value) {
                await loadLocationOptions(
                    `/api/location/zds?commune=${comSelect.value}`,
                    zdSelect,
                    'mo_zd',
                    'mo_zd',
                    `zd_${comSelect.value}`
                );
            }
            
            // Mettre √† jour les graphiques
            debouncedUpdateCharts({
                region: getSelectValue('region'),
                departement: getSelectValue('departement'),
                commune: comSelect.value,
                zd: ''
            });
        });
    }
    
    // √âv√©nement pour la ZD
    if (zdSelect && zdSelect.tagName === 'SELECT') {
        zdSelect.addEventListener("change", () => {
            console.log('üîò ZD changed:', zdSelect.value);
            debouncedUpdateCharts({
                region: getSelectValue('region'),
                departement: getSelectValue('departement'),
                commune: getSelectValue('commune'),
                zd: zdSelect.value
            });
        });
    }
    
    // Initialiser les graphiques avec les filtres actuels
    const initialFilters = {
        region: getSelectValue('region'),
        departement: getSelectValue('departement'),
        commune: getSelectValue('commune'),
        zd: getSelectValue('zd')
    };
    
    console.log('üìä Initial filters:', initialFilters);
    
    // Attendre que Chart.js soit charg√©
    if (typeof Chart === 'undefined') {
        console.error('‚ùå Chart.js not loaded!');
        return;
    }
    
    // Lancer le premier chargement des graphiques
    setTimeout(() => {
        updateCharts(initialFilters);
    }, 500);
});
</script>
<script src="assets/libs/chart.js/chart.umd.js"></script>