<div id="loader" class="loader-overlay hidden">
  <div class="spinner"></div>
</div>
<style>
/* Overlay sombre */
.loader-overlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(255, 255, 255, 0.7);
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 9999;
}

/* Cacher l'overlay */
.hidden {
  display: none !important;
}

/* Le spinner */
.spinner {
  width: 55px;
  height: 55px;
  border: 6px solid #ddd;
  border-top-color: #12A537; 
  border-radius: 50%;
  animation: spin 0.9s linear infinite;
}

/* Animation */
@keyframes spin {
  to {
    transform: rotate(360deg);
  }
}

.pie-container {
    width: 350px;   /* Ajuste ici */
    height: 350px;  /* idem */
    margin: 0 auto; /* centre le graphique */
}

.pie-container canvas {
    max-width: 100% !important;
    max-height: 100% !important;
}


</style>
<div class="row">
	<div class="col-12">
		<div class="page-title-box d-sm-flex align-items-center justify-content-between bg-galaxy-transparent">
			<h4 class="mb-sm-0">Tableau de bord du RGPH-5</h4>
			<div class="page-title-right">
				<ol class="breadcrumb m-0">
					<li class="breadcrumb-item active">Graphiques</li>
				</ol>

			</div>

		</div>
	</div>
	<div class="col-12">
  <div class="page-title-box d-sm-flex align-items-center justify-content-between bg-galaxy-transparent p-3 rounded shadow-sm">
    <div class="row g-3 w-100">
      
<div class="row">
  <!-- R√©gion -->
  <div class="col-3">
    <label>R√©gion</label>
    <% if (user.canChangeRegion) { %>
      <!-- ROLE_GLOBAL : Select actif avec options pr√©charg√©es -->
      <select id="region" class="form-select">
        <option value="">-- S√©lectionner --</option>
        <% selects.regions.forEach(region => { %>
          <option value="<%= region.code_region %>"><%= region.region %></option>
        <% }); %>
      </select>
    <% } else { %>
      <!-- R√¥les REGIONAL, DEPARTEMENTAL, COMMUNAL : R√©gion fix√©e -->
      <% const defaultRegion = user.defaultRegion || selects.regions[0]?.code_region || ''; %>
      <% const defaultRegionName = selects.regions[0]?.region || 'R√©gion non disponible'; %>
      
      <input type="hidden" id="region" value="<%= defaultRegion %>">
      <div class="form-control-plaintext" style="padding:0.5rem; border:1px solid #ddd; background:#f8f9fa;">
        <%= defaultRegionName %>
      </div>
    <% } %>
  </div>
  
  <!-- D√©partement -->
  <!-- D√©partement -->
<div class="col-3">
  <label>D√©partement</label>
  <% if (user.canChangeDepartement) { %>  <!-- CHANGER canChangeRegion EN canChangeDepartement -->
    <select id="departement" class="form-select">
      <option value="">-- S√©lectionner --</option>
    </select>
  <% } else { %>
    <% const defaultDept = user.defaultDepartement || selects.departements[0]?.code_departement || ''; %>
    <% const defaultDeptName = selects.departements[0]?.departement || 'D√©partement non disponible'; %>
    
    <input type="hidden" id="departement" value="<%= defaultDept %>">
    <div class="form-control-plaintext" style="padding:0.5rem; border:1px solid #ddd; background:#f8f9fa;">
      <%= defaultDeptName %>
    </div>
  <% } %>
</div>
  
  <!-- Commune -->
  <div class="col-3">
    <label>Commune</label>
    <% if (user.canChangeCommune) { %>
      <!-- ROLE_GLOBAL, REGIONAL, DEPARTEMENTAL : Select actif -->
      <select id="commune" class="form-select">
        <option value="">-- S√©lectionner --</option>
      </select>
    <% } else { %>
      <!-- ROLE_COMMUNAL : Commune fix√©e -->
      <% const defaultCommune = user.defaultCommune || selects.communes[0]?.code_commune || ''; %>
      <% const defaultCommuneName = selects.communes[0]?.commune || 'Commune non disponible'; %>
      
      <input type="hidden" id="commune" value="<%= defaultCommune %>">
      <div class="form-control-plaintext" style="padding:0.5rem; border:1px solid #ddd; background:#f8f9fa;">
        <%= defaultCommuneName %>
      </div>
    <% } %>
  </div>
  
  <!-- ZD -->
  <div class="col-3">
    <label>Zone de d√©nombrement (ZD)</label>
    <!-- TOUS les r√¥les peuvent changer de ZD -->
    <select id="zd" class="form-select">
      <option value="">-- S√©lectionner --</option>
    </select>
  </div>
</div>
</div></div>
<div class="row">
	<div class="col-xl-6">
		<div class="card">
			<div class="card-header">
				<h4 class="card-title mb-0">PYRAMIDE DES AGES</h4>
			</div>
			<div class="card-body">
				<canvas id="chartPyramide" ></canvas>
			</div>
		</div>
	</div>
   <div class="col-xl-6">
		<div class="card">
			<div class="card-header">
				<h4 class="card-title mb-0">R√©partition de la population par sexe</h4>
			</div>
			<div class="card-body">
				<canvas id="genderChart">
</canvas>
			</div>
		</div>
	</div>
   
 </div>
<div class="row">
   <div class="col-xl-6">
		<div class="card">
			<div class="card-header">
				<h4 class="card-title mb-0">Population collect√©e par rapport √† la carto</h4>
			</div>
			<div class="card-body pie-container">
				<canvas id="popChartPie"  width="900" height="500"></canvas>
			</div>
		</div>
	</div>
    <div class="col-xl-6">
		<div class="card">
			<div class="card-header">
				<h4 class="card-title mb-0">Population collect√©e vs cartographi√©e par r√©gion</h4>
			</div>
			<div class="card-body pie-container">
				    <canvas id="popChartBarRegions"></canvas>
			</div>
		</div>
	</div>
</div>


<script>
document.addEventListener("DOMContentLoaded", async () => {
    const regionSelect = document.getElementById('region');
    const deptSelect = document.getElementById('departement');
    const comSelect = document.getElementById('commune');
    const zdSelect = document.getElementById('zd');
    
    // Variables pour stocker les instances de graphiques
    let pyramidChart = null;
    let genderChart = null;
    let popPieChart = null;
    let popBarChart = null;

    // Cache intelligent
    const SmartCache = {
        store: {},
        async fetch(url) {
            if (this.store[url]) return this.store[url];
            console.log('üì• Chargement:', url);
            const res = await fetch(url);
            if (!res.ok) throw new Error("Erreur API: " + url);
            const data = await res.json();
            this.store[url] = data;
            return data;
        },
        clear() {
            this.store = {};
        }
    };

    // Utils
    function resetSelect(select, placeholder = "-- S√©lectionner --") {
        if (select && select.tagName === 'SELECT') {
            select.innerHTML = '';
            const option = new Option(placeholder, "");
            select.appendChild(option);
            select.disabled = false;
        }
    }

    function populateSelect(select, items, valueField, textField) {
        if (!select || select.tagName !== 'SELECT') return;
        
        resetSelect(select);
        if (items?.length) {
            items.forEach(item => {
                const option = new Option(item[textField], item[valueField]);
                select.appendChild(option);
            });
            select.disabled = false;
        } else {
            select.disabled = true;
        }
    }

    const userRole = '<%= user.role %>';
    
    // V√©rifier si un √©l√©ment est un input hidden (verrouill√©)
    const isLocked = (element) => {
        if (!element) return false;
        return element.tagName === 'INPUT' && element.type === 'hidden';
    };
    
    // Donn√©es pr√©charg√©es
    const allData = { departements: {}, communes: {}, zds: {} };

    // ‚úÖ PR√âCHARGEMENT SELON LE R√îLE
    if (userRole === 'ROLE_GLOBAL') {
        // Charger toutes les r√©gions
        if (regionSelect && regionSelect.tagName === 'SELECT') {
            const regions = await SmartCache.fetch('/api/location/regions');
            populateSelect(regionSelect, regions, 'code_region', 'region');
            
            // Pr√©charger tout
            for (const r of regions) {
                allData.departements[r.code_region] = await SmartCache.fetch(`/api/location/departements?region=${r.code_region}`);
                for (const d of allData.departements[r.code_region]) {
                    allData.communes[d.code_departement] = await SmartCache.fetch(`/api/location/communes?departement=${d.code_departement}`);
                }
            }
        }
    } 
    else if (userRole === 'ROLE_REGIONAL') {
        // R√©gion fixe, charger ses d√©partements
        const preselectedRegion = '<%= user.defaultRegion %>';
        if (preselectedRegion && deptSelect && deptSelect.tagName === 'SELECT') {
            const departements = await SmartCache.fetch(`/api/location/departements?region=${preselectedRegion}`);
            populateSelect(deptSelect, departements, 'code_departement', 'departement');
            allData.departements[preselectedRegion] = departements;
            
            // Pr√©charger les communes
            for (const d of departements) {
                allData.communes[d.code_departement] = await SmartCache.fetch(`/api/location/communes?departement=${d.code_departement}`);
            }
        }
    } 
    else if (userRole === 'ROLE_DEPARTEMENTAL') {
        const preselectedDept = '<%= user.defaultDepartement %>';
        if (preselectedDept && comSelect && comSelect.tagName === 'SELECT') {
            const communes = await SmartCache.fetch(`/api/location/communes?departement=${preselectedDept}`);
            populateSelect(comSelect, communes, 'code_commune', 'commune');
            allData.communes[preselectedDept] = communes;
        }
    }

    // ‚úÖ √âCOUTEURS
    if (regionSelect && !isLocked(regionSelect)) {
        regionSelect.addEventListener('change', async () => {
            console.log('üîò R√©gion chang√©e:', regionSelect.value);
            
            if (deptSelect && deptSelect.tagName === 'SELECT') {
                const deps = allData.departements[regionSelect.value] || [];
                populateSelect(deptSelect, deps, 'code_departement', 'departement');
            }
            
            if (comSelect && comSelect.tagName === 'SELECT') {
                resetSelect(comSelect);
            }
            
            if (zdSelect && zdSelect.tagName === 'SELECT') {
                resetSelect(zdSelect);
            }
            
            await updateCharts({ 
                region: regionSelect.value 
            });
        });
    }

    if (deptSelect && !isLocked(deptSelect)) {
        deptSelect.addEventListener('change', async () => {
            console.log('üîò D√©partement chang√©:', deptSelect.value);
            
            if (comSelect && comSelect.tagName === 'SELECT') {
                const loadComms = async () => {
                    const deptCode = deptSelect.value;
                    if (!deptCode) {
                        resetSelect(comSelect);
                        return;
                    }
                    
                    if (!allData.communes[deptCode]) {
                        allData.communes[deptCode] = await SmartCache.fetch(`/api/location/communes?departement=${deptCode}`);
                    }
                    
                    populateSelect(comSelect, allData.communes[deptCode], 'code_commune', 'commune');
                };
                await loadComms();
            }
            
            if (zdSelect && zdSelect.tagName === 'SELECT') {
                resetSelect(zdSelect);
            }
            
            await updateCharts({ 
                region: regionSelect ? regionSelect.value : '<%= user.defaultRegion %>',
                departement: deptSelect.value 
            });
        });
    }

    if (comSelect && !isLocked(comSelect)) {
        comSelect.addEventListener('change', async () => {
            console.log('üîò Commune chang√©e:', comSelect.value);
            
            if (zdSelect && zdSelect.tagName === 'SELECT') {
                const loadZds = async () => {
                    const communeCode = comSelect.value;
                    if (!communeCode) {
                        resetSelect(zdSelect);
                        return;
                    }
                    
                    if (!allData.zds[communeCode]) {
                        allData.zds[communeCode] = await SmartCache.fetch(`/api/location/zds?commune=${communeCode}`);
                    }
                    
                    populateSelect(zdSelect, allData.zds[communeCode], 'mo_zd', 'mo_zd');
                };
                await loadZds();
            }
            
            await updateCharts({ 
                region: regionSelect ? regionSelect.value : '<%= user.defaultRegion %>',
                departement: deptSelect ? deptSelect.value : '<%= user.defaultDepartement %>',
                commune: comSelect.value 
            });
        });
    }

    if (zdSelect && zdSelect.tagName === 'SELECT') {
        zdSelect.addEventListener('change', async () => {
            console.log('üîò ZD chang√©e:', zdSelect.value);
            await updateCharts({ 
                region: regionSelect ? regionSelect.value : '<%= user.defaultRegion %>',
                departement: deptSelect ? deptSelect.value : '<%= user.defaultDepartement %>',
                commune: comSelect ? comSelect.value : '<%= user.defaultCommune %>',
                zd: zdSelect.value 
            });
        });
    }

    // ‚úÖ FONCTION PRINCIPALE POUR METTRE √Ä JOUR LES GRAPHIQUES
    async function updateCharts(filters = {}) {
        const loader = document.getElementById('loader');
        if (loader) loader.classList.remove('hidden');
        
        console.log('üìä Mise √† jour graphiques avec filtres:', filters);
        
        try {
            // Nettoyer les filtres vides
            const cleanFilters = {};
            for (const [key, value] of Object.entries(filters)) {
                if (value && value.toString().trim() !== '') {
                    cleanFilters[key] = value;
                }
            }
            
            // Construire l'URL
            const params = new URLSearchParams(cleanFilters);
            const response = await fetch(`/api/charts?${params}`);
            
            if (!response.ok) {
                throw new Error(`Erreur HTTP ${response.status}`);
            }
            
            const chartData = await response.json();
            console.log('üìà Donn√©es re√ßues:', chartData);
            
            // Mettre √† jour les graphiques
            if (chartData.pyramideAges) {
                updatePyramidChart(chartData.pyramideAges);
            }
            
            if (chartData.hommes !== undefined && chartData.femmes !== undefined) {
                updateGenderChart(chartData.hommes, chartData.femmes);
            }
            
            if (chartData.populationCarto !== undefined && chartData.populationCollectee !== undefined) {
                updatePopulationPieChart(chartData.populationCollectee, chartData.populationCarto);
            }
            
            if (chartData.regionsData) {
                updateRegionsBarChart(chartData.regionsData);
            }
            
        } catch (error) {
            console.error('‚ùå Erreur lors du chargement des graphiques:', error);
        } finally {
            if (loader) loader.classList.add('hidden');
        }
    }

    // ‚úÖ FONCTION POUR LE GRAPHIQUE PYRAMIDE DES √ÇGES
    function updatePyramidChart(pyramideData) {
        const ctx = document.getElementById('chartPyramide');
        if (!ctx) {
            console.error('‚ùå Canvas chartPyramide non trouv√©');
            return;
        }
        
        // D√©truire le graphique existant
        if (pyramidChart) {
            pyramidChart.destroy();
        }
        
        // Pr√©parer les donn√©es
        const labels = pyramideData.map(item => item.tranche);
        const hommesData = pyramideData.map(item => item.hommes || 0);
        const femmesData = pyramideData.map(item => item.femmes || 0);
        
        // Convertir les valeurs hommes en n√©gatives pour l'effet pyramide
        const hommesNegatifs = hommesData.map(value => -Math.abs(value));
        
        pyramidChart = new Chart(ctx, {
            type: 'bar',
            data: {
                labels: labels,
                datasets: [
                    {
                        label: 'Hommes',
                        data: hommesNegatifs,
                        backgroundColor: 'rgba(54, 162, 235, 0.7)',
                        borderColor: 'rgba(54, 162, 235, 1)',
                        borderWidth: 1
                    },
                    {
                        label: 'Femmes',
                        data: femmesData,
                        backgroundColor: 'rgba(255, 99, 132, 0.7)',
                        borderColor: 'rgba(255, 99, 132, 1)',
                        borderWidth: 1
                    }
                ]
            },
            options: {
                indexAxis: 'y',
                responsive: true,
                maintainAspectRatio: true,
                plugins: {
                    title: {
                        display: true,
                        text: 'Pyramide des √Çges'
                    },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                let label = context.dataset.label || '';
                                if (label) {
                                    label += ': ';
                                }
                                label += Math.abs(context.raw).toLocaleString();
                                return label;
                            }
                        }
                    }
                },
                scales: {
                    x: {
                        stacked: true,
                        ticks: {
                            callback: function(value) {
                                return Math.abs(value).toLocaleString();
                            }
                        },
                        title: {
                            display: true,
                            text: 'Population'
                        }
                    },
                    y: {
                        stacked: true,
                        title: {
                            display: true,
                            text: 'Tranche d\'√¢ge'
                        }
                    }
                }
            }
        });
    }

    // ‚úÖ FONCTION POUR LE GRAPHIQUE R√âPARTITION PAR SEXE
    function updateGenderChart(hommes, femmes) {
        const ctx = document.getElementById('genderChart');
        if (!ctx) {
            console.error('‚ùå Canvas genderChart non trouv√©');
            return;
        }
        
        // D√©truire le graphique existant
        if (genderChart) {
            genderChart.destroy();
        }
        
        const total = hommes + femmes;
        const pourcentageHommes = total > 0 ? (hommes / total * 100).toFixed(1) : 0;
        const pourcentageFemmes = total > 0 ? (femmes / total * 100).toFixed(1) : 0;
        
        genderChart = new Chart(ctx, {
            type: 'doughnut',
            data: {
                labels: [`Hommes (${pourcentageHommes}%)`, `Femmes (${pourcentageFemmes}%)`],
                datasets: [{
                    data: [hommes, femmes],
                    backgroundColor: [
                        'rgba(54, 162, 235, 0.8)',
                        'rgba(255, 99, 132, 0.8)'
                    ],
                    borderColor: [
                        'rgba(54, 162, 235, 1)',
                        'rgba(255, 99, 132, 1)'
                    ],
                    borderWidth: 2
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: true,
                plugins: {
                    legend: {
                        position: 'bottom',
                    },
                    title: {
                        display: true,
                        text: `R√©partition par sexe - Total: ${total.toLocaleString()}`
                    },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                const label = context.label || '';
                                const value = context.raw || 0;
                                const percentage = total > 0 ? ((value / total) * 100).toFixed(1) : 0;
                                return `${label}: ${value.toLocaleString()} (${percentage}%)`;
                            }
                        }
                    }
                }
            }
        });
    }

    // ‚úÖ FONCTION POUR LE GRAPHIQUE CAMEMBERT POPULATION COLLECT√âE VS CARTO
    function updatePopulationPieChart(collectee, carto) {
        const ctx = document.getElementById('popChartPie');
        if (!ctx) {
            console.error('‚ùå Canvas popChartPie non trouv√©');
            return;
        }
        
        // D√©truire le graphique existant
        if (popPieChart) {
            popPieChart.destroy();
        }
        
        const pourcentageCollectee = carto > 0 ? (collectee / carto * 100).toFixed(1) : 0;
        
        popPieChart = new Chart(ctx, {
            type: 'pie',
            data: {
                labels: [
                    `Collect√©e (${pourcentageCollectee}%)`, 
                    `Restante (${(100 - pourcentageCollectee).toFixed(1)}%)`
                ],
                datasets: [{
                    data: [collectee, Math.max(0, carto - collectee)],
                    backgroundColor: [
                        'rgba(75, 192, 192, 0.8)',
                        'rgba(201, 203, 207, 0.8)'
                    ],
                    borderColor: [
                        'rgba(75, 192, 192, 1)',
                        'rgba(201, 203, 207, 1)'
                    ],
                    borderWidth: 2
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: true,
                plugins: {
                    legend: {
                        position: 'bottom',
                    },
                    title: {
                        display: true,
                        text: `Progression: ${pourcentageCollectee}% (${collectee.toLocaleString()}/${carto.toLocaleString()})`
                    },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                const label = context.label || '';
                                const value = context.raw || 0;
                                const total = carto;
                                const percentage = total > 0 ? ((value / total) * 100).toFixed(1) : 0;
                                return `${label}: ${value.toLocaleString()} (${percentage}%)`;
                            }
                        }
                    }
                }
            }
        });
    }

    // ‚úÖ FONCTION POUR LE GRAPHIQUE BARRES PAR R√âGION
    function updateRegionsBarChart(regionsData) {
        const ctx = document.getElementById('popChartBarRegions');
        if (!ctx) {
            console.error('‚ùå Canvas popChartBarRegions non trouv√©');
            return;
        }
        
        // D√©truire le graphique existant
        if (popBarChart) {
            popBarChart.destroy();
        }
        
        // Si pas de donn√©es r√©gionales sp√©cifiques, cr√©er un graphique simple
        if (!regionsData || regionsData.length === 0) {
            // On peut cr√©er un message ou graphique alternatif
            popBarChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: ['Aucune donn√©e'],
                    datasets: [{
                        label: 'Donn√©es non disponibles',
                        data: [0],
                        backgroundColor: 'rgba(201, 203, 207, 0.8)'
                    }]
                },
                options: {
                    responsive: true,
                    plugins: {
                        title: {
                            display: true,
                            text: 'Donn√©es r√©gionales non disponibles'
                        }
                    }
                }
            });
            return;
        }
        
        // Pr√©parer les donn√©es
        const labels = regionsData.map(region => region.nom || `R√©gion ${region.code}`);
        const collecteeData = regionsData.map(region => region.collectee || 0);
        const cartoData = regionsData.map(region => region.carto || 0);
        
        // Calculer les pourcentages
        const percentageData = regionsData.map(region => {
            if (region.carto > 0) {
                return (region.collectee / region.carto * 100).toFixed(1);
            }
            return 0;
        });
        
        popBarChart = new Chart(ctx, {
            type: 'bar',
            data: {
                labels: labels,
                datasets: [
                    {
                        label: 'Population Collect√©e',
                        data: collecteeData,
                        backgroundColor: 'rgba(75, 192, 192, 0.8)',
                        borderColor: 'rgba(75, 192, 192, 1)',
                        borderWidth: 1
                    },
                    {
                        label: 'Population Cartographi√©e',
                        data: cartoData,
                        backgroundColor: 'rgba(255, 159, 64, 0.8)',
                        borderColor: 'rgba(255, 159, 64, 1)',
                        borderWidth: 1
                    },
                    {
                        label: 'Taux (%)',
                        data: percentageData,
                        type: 'line',
                        fill: false,
                        borderColor: 'rgba(153, 102, 255, 1)',
                        backgroundColor: 'rgba(153, 102, 255, 0.8)',
                        yAxisID: 'yPercentage'
                    }
                ]
            },
            options: {
                responsive: true,
                maintainAspectRatio: true,
                interaction: {
                    mode: 'index',
                    intersect: false
                },
                plugins: {
                    title: {
                        display: true,
                        text: 'Population par r√©gion'
                    },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                let label = context.dataset.label || '';
                                const value = context.raw;
                                
                                if (context.dataset.label === 'Taux (%)') {
                                    return `${label}: ${value}%`;
                                } else {
                                    return `${label}: ${value.toLocaleString()}`;
                                }
                            }
                        }
                    }
                },
                scales: {
                    x: {
                        title: {
                            display: true,
                            text: 'R√©gions'
                        }
                    },
                    y: {
                        type: 'linear',
                        display: true,
                        position: 'left',
                        title: {
                            display: true,
                            text: 'Population'
                        },
                        ticks: {
                            callback: function(value) {
                                return value.toLocaleString();
                            }
                        }
                    },
                    yPercentage: {
                        type: 'linear',
                        display: true,
                        position: 'right',
                        title: {
                            display: true,
                            text: 'Taux (%)'
                        },
                        min: 0,
                        max: 100,
                        grid: {
                            drawOnChartArea: false
                        },
                        ticks: {
                            callback: function(value) {
                                return value + '%';
                            }
                        }
                    }
                }
            }
        });
    }

    // ‚úÖ INITIALISATION DES GRAPHIQUES
    const initialFilters = {
        region: regionSelect ? (regionSelect.tagName === 'SELECT' ? regionSelect.value : regionSelect.value) : '<%= user.defaultRegion %>',
        departement: deptSelect ? (deptSelect.tagName === 'SELECT' ? deptSelect.value : deptSelect.value) : '<%= user.defaultDepartement %>',
        commune: comSelect ? (comSelect.tagName === 'SELECT' ? comSelect.value : comSelect.value) : '<%= user.defaultCommune %>',
        zd: zdSelect ? zdSelect.value : ''
    };
    
    console.log('üìä Filtres initiaux:', initialFilters);
    
    // D√©marrer l'initialisation apr√®s un d√©lai pour √™tre s√ªr que Chart.js est charg√©
    setTimeout(async () => {
        if (typeof Chart === 'undefined') {
            console.error('‚ùå Chart.js non charg√©!');
            return;
        }
        console.log('‚úÖ Chart.js charg√©, initialisation des graphiques...');
        await updateCharts(initialFilters);
    }, 500);
});
</script>
<script src="assets/libs/chart.js/chart.umd.js"></script>


